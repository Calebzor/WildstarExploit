--[[

PKDLib - Packetdancer's WildStar Utility Library
(c)2013 Packetdancer

Feel free to reuse this in any of your own addons, but if you want

--]]

local LibStub = _G["LibStub"]
local PKDLib = LibStub:NewLibrary("PKDLib-1.0",2)
if (not PKDLib) then return end

PKDLib.CodeEnumAnchorPosition = {
    AnchorTop = 0,
	AnchorBottom = 1
}

local DropButtonMenu = {
} 

-- PKDLib:UUID()
--
-- Returns a newly-created UUID in string form.
--
--
function PKDLib:UUID()
	local _rnd = math.random
	local _sub = string.sub
	local _fmt = string.format
	--
	local time_low = os.time()
	math.randomseed( time_low )
	--
	local time_mid = _rnd(0, 65535)
	--
	local time_hi = _rnd(0, 65535 )
	time_hi = self:padbits( self:num2bs(time_hi), 16 )
	time_hi = _sub( time_hi, 1, 12 )
	local time_hi_and_version = self:bs2num( time_hi .. "0100" )
	--
	local clock_seq_hi_res = _rnd(0,255)
	clock_seq_hi_res = self:padbits( self:num2bs(clock_seq_hi_res), 8 )
	clock_seq_hi_res = _sub( clock_seq_hi_res, 1, 6) .. "01"
	--
	local clock_seq_low = _rnd(0,255)
	clock_seq_low = self:padbits( self:num2bs(clock_seq_low), 8 )
	--
	local clock_seq = self:bs2num(clock_seq_hi_res .. clock_seq_low)
	--
	local node = {}
	node[1]= (128 + _rnd(0,127) )
	for i=2,6 do
		node[i] = _rnd(0,255)
	end
	--
	local guid = ""
	guid = guid .. self:padbits(_fmt("%X",time_low), 8) .. "-"
	guid = guid .. self:padbits(_fmt("%X",time_mid), 4) .. "-"
	guid = guid .. self:padbits(_fmt("%X",time_hi_and_version), 4) .. "-"
	guid = guid .. self:padbits(_fmt("%X",clock_seq), 4) .. "-"
	--
	for i=1,6 do
		guid = guid .. self:padbits(_fmt("%X",node[i]), 2)
	end
	--
	return guid
end

-- PKDLib:Dump(variable)
--
-- Will output the contents of variable on the Debug channel.
-- If variable is userdata or table, it will print the contents 
-- recursively, with indenting.
-- 
function PKDLib:Dump(variable) 
	self:DumpVariableIndentedLabeled("", variable, 0)
end

-- PKDLib:IndexOfTableString(t, string)
--
-- Returns the index of string in table t,
-- or 0 if the table does not contain the string.
--
function PKDLib:IndexOfTableString(t, string)
   local stringIndex = 0

   for idx,tableString in ipairs(t) do 
      if (tableString == string) then
         stringIndex = idx
      end
   end

   return stringIndex
end

-- PKDLib:AddTableString(t, string)
--
-- Adds a string to a table if, and only if, that string is 
-- not already present in the table.
--
function PKDLib:AddTableString(t, string)
   local stringIndex = IndexOfTableString(t, string)

   if (stringIndex == 0) then table.insert(t, string) end
end

-- PKDLib:RemoveTableString(t, string)
--
-- Removes a string from the table if present.
--
function PKDLib:RemoveTableString(t, string)
   local stringIndex = IndexOfTableString(t, string)

   if (stringIndex ~= 0) then table.remove(t,stringIndex) end
end

-- PKDLib:SplitString(string, delimiter)
--
-- Splits string into an array, separating on instances of delimiter.
--
function PKDLib:SplitString(str, delimiter)
  local result = { }
  local from  = 1
  local delim_from, delim_to = string.find( str, delimiter, from  )
  while delim_from do
    table.insert( result, string.sub( str, from , delim_from-1 ) )
    from  = delim_to + 1
    delim_from, delim_to = string.find( str, delimiter, from  )
  end
  table.insert( result, string.sub( str, from  ) )
  return result
end

-- PKDLib:BreakString(string, limit)
--
-- Breaks string into an array where each is no longer than
-- limit characters long, honoring word boundaries.
--
function PKDLib:BreakString(str, limit)
  limit = limit or 300
  local here = 1
  local wrapped = str:gsub("(%s+)()(%S+)()",
                          function(sp, st, word, fi)
                            if fi-here > limit then
                              here = st
                              return "\n"..word
                            end
                          end)
                          
  return self:SplitString(wrapped,"\n")
end

-- PKDLib:DropButtonMenu(wnd, prototypeFile, prototypeForm, objCallback)
--
-- Creates a new DropButtonMenu, contained within the form control wnd, 
-- where new items will be instances of prototypeForm from prototypeFile,
-- using objCallback as the callback for Apollo.LoadForm()
--
function PKDLib:DropButtonMenu(wnd, strPrototypeFile, strPrototypeForm, objCallback)
	local menu = DropButtonMenu:new()
	menu:Bind(wnd, strPrototypeFile, strPrototypeForm, objCallback)
	
	return menu 
end

-- SUPPORT CLASSES

-- DropButtonMenu class functionality
--
function DropButtonMenu:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self 

    -- initialize variables here
    self.eAnchorLogic = PKDLib.CodeEnumAnchorPosition.AnchorTop
    return o
end

function DropButtonMenu:Bind(wnd, strPrototypeFile, strPrototypeForm, objCallback)
    if (self.wnd ~= nil) then self:Teardown() end

    if (wnd == nil or objCallback == nil) then return end
    
    self.wnd = wnd

	local l, t, r, b = wnd:GetAnchorOffsets()
	self.wndAnchors = { l = l, t = t, r = r, b = b }

    self.strPrototypeFile = strPrototypeFile
    self.strPrototypeForm = strPrototypeForm
    self.objCallback = objCallback
    self.nItems = 0
    self.iItemHeight = 0
end

function DropButtonMenu:Teardown()
    if (self.wnd == nil) then return end

    self:Show(false)
    self:RemoveItems()    
    self.wnd = nil
    self.strPrototypeFile = nil
    self.strPrototypeForm = nil
    self.objCallback = nil
    self.nItems = 0
    self.iItemHeight = 0
end

function DropButtonMenu:RemoveItems()
    if (self.wnd == nil) then return end
    
    self.wnd:DestroyChildren()
	self.nItems = 0
end

function DropButtonMenu:SetAnchorLogic(eAnchorPosition)
	self.eAnchorLogic = eAnchorPosition
end

function DropButtonMenu:SetAnchorFrom(iLocation)
	if (self.eAnchorLogic == PKDLib.CodeEnumAnchorPosition.AnchorTop) then 
		self.wndAnchors.t = iLocation
	else
		self.wndAnchors.b = iLocation
	end
end

function DropButtonMenu:AddItem(title, userdata)
    if (self.wnd == nil or self.strPrototypeFile == nil or 
        self.strPrototypeForm == nil or self.objCallback == nil) then return nil end
    
    local wndItem = Apollo.LoadForm(self.strPrototypeFile, self.strPrototypeForm, 
                                    self.wnd, self.objCallback)
                                    
    if (wndItem == nil) then return nil end

    wndItem:SetData(userdata)

    if (self.iItemHeight == 0) then
        local l,t,r,b = wndItem:GetAnchorOffsets()
        self.iItemHeight = math.abs(b - t)
    end
    
	self.nItems = self.nItems + 1

    local wndTitle = wndItem:FindChild("ItemText")
    if (wndTitle ~= nil) then wndTitle:SetText(title) else wndItem:SetText(title) end
    
    return wndItem
end

function DropButtonMenu:Show(bShow)
    if (self.wnd == nil) then return end
    
    if (not bShow) then
        self.wnd:Show(false)
        return
    end

    local iHeight = self.nItems * self.iItemHeight
    
	local b = self.wndAnchors.b
	local t = self.wndAnchors.t
	local r = self.wndAnchors.r
	local l = self.wndAnchors.l
	
    if (self.eAnchorLogic == PKDLib.CodeEnumAnchorPosition.AnchorTop) then
        b = t + iHeight
    else
        t = b - iHeight
    end    

    self.wnd:SetAnchorOffsets(l,t,r,b)
	self.wnd:ArrangeChildrenVert()
    self.wnd:Show(true)
end

function DropButtonMenu:IsShown()
	return self.wnd:IsShown()
end

-- INTERNAL SUPPORT FUNCTIONS

function PKDLib:num2bs(num)
	local _mod = math.mod
	local _floor = math.floor
	--
	local index, result = 1 , ""
	if(num == 0) then return "0" end
	while(num  > 0) do
		 result = _mod(num,2) .. result
		 num = _floor(num*0.5)
	end              
	return result
end
--
function PKDLib:bs2num(num)
	local _sub = string.sub
	local index, result = 0, 0
	if(num == "0") then return 0; end
	for p=#num,1,-1 do
		local this_val = _sub( num, p,p )
		if this_val == "1" then
			result = result + ( 2^index )
		end
		index=index+1
	end
	return result
end
--
function PKDLib:padbits(num,bits)
	if #num == bits then return num end
	if #num > bits then Print("too many bits") end
	local pad = bits - #num
	for i=1,pad do
		num = "0" .. num
	end
	return num
end


-- This function is used internally for Dump(), but can be 
-- called independently if you really want.
function PKDLib:DumpVariableIndentedLabeled(k, v, nIndent)
	local strIndent = ""
	for i = 1,(nIndent * 2) do strIndent = strIndent .. " " end

	if (string.sub(k,1,2) ~= "__") then 
  		if type(v) == "string" then Print(strIndent .. k .. " (string): " .. tostring(v))
  		elseif type(v) == "number" then Print(strIndent .. k .. " (number): " .. tostring(v))
  		elseif type(v) == "function" then Print(strIndent .. k .. " (function)")
  		elseif type(v) == "boolean" then Print(strIndent .. k .. " (boolean): " .. tostring(v))
  		elseif type(v) == "nil" then Print(strIndent .. k .. " (nil)")
  		elseif type(v) == "thread" then Print(strIndent .. k .. " (thread)")
  		elseif type(v) == "userdata" then 
  			Print(strIndent .. k .. " (userdata): ")
		    for k2,v2 in pairs(getmetatable(v)) do
	  			if (string.sub(k2,1,2) ~= "__") then 
					self:DumpVariableIndentedLabeled(k2,v2,nIndent + 1)
				end
			end
        elseif type(v) == "table" then 
            Print(strIndent .. k .. " (table):")
		    for k2,v2 in pairs(v) do
	  			if (string.sub(k2,1,2) ~= "__") then 
					self:DumpVariableIndentedLabeled(k2,v2,nIndent + 1)
				end
			end
        end
	end
end

